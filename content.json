{"meta":{"title":"封阳葵的博客","subtitle":"","description":"","author":"封阳葵","url":"https://github.com/fengyk1","root":"/"},"pages":[{"title":"about","date":"2021-06-03T04:58:39.000Z","updated":"2021-06-03T04:58:52.451Z","comments":true,"path":"about/index.html","permalink":"https://github.com/fengyk1/about/index.html","excerpt":"","text":""}],"posts":[{"title":"Promise原理与实现","slug":"Promise原理与实现","date":"2021-09-14T03:20:19.000Z","updated":"2021-09-14T03:21:02.499Z","comments":true,"path":"2021/09/14/Promise原理与实现/","link":"","permalink":"https://github.com/fengyk1/2021/09/14/Promise%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/","excerpt":"","text":"Promise原理与实现Promise的状态 一个Promise必然处于一下几个状态之一 pendding 初始状态 等待着，既没有成功，也没有失败 fulfilled 成功 rejected 失败 等待状态的Promise会在调用resolve后会变为成功状态，调用reject后变为失败状态，接下来使用es6实现一个最简单的Promise 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273const Status = &#123; PENDDING: &#x27;PENDDING&#x27;, FULFILLED: &#x27;FULFILLED&#x27;, REJECTED: &#x27;REJECTED&#x27;&#125;// Promise类class Promise&#123; // 传入的函数 constructor(exectuer)&#123; // 定义成功函数数组，用来存放成功后的回调函数 this.resolveCallbacks = [] // 定义失败函数数组，用来存放失败后的回调函数 this.rejectCallbacks = [] // 状态 初始状为PENDDING this.status = Status.PENDDING // 调用resolve后传入的值 this.value = undefined; // 调用reject后传入的值 this.reason = undefined; // resolve方法 const resolve = (value)=&gt;&#123; // PENDDING状态下保存相关数据 if (this.status === Status.PENDDING)&#123; this.value = value; this.status = Status.FULFILLED; this.resolveCallbacks.forEach(cb=&gt;cb()) &#125; &#125; // reject方法 const reject = (reason)=&gt;&#123; if (this.status === Status.PENDDING)&#123; this.reason = reason; this.status = Status.REJECTED; this.rejectCallbacks.forEach(cb=&gt;cb()) &#125; &#125; try&#123; exectuer(resolve,reject) &#125;catch(e)&#123; reject(e) &#125; &#125; /** * 注:这里只是把函数保存到数组里面，实际是在resolve方法里面执行 * @onFulfilled 成功执行的函数 * @onRejected 失败执行的函数 */ then(onFulfilled,onRejected)&#123; const fulfulled = onFulfilled || (x=&gt;x) const rejected = onRejected || (x=&gt;x) switch(this.status)&#123; // PENDDING状态把成功和失败的函数放到数组里面 case Status.PENDDING: this.resolveCallbacks.push(()=&gt;&#123; fulfulled(this.value) &#125;) this.rejectCallbacks.push(()=&gt;&#123; rejected(this.reason) &#125;) break; // 进入then方法已经成功，执行onFulfilled函数 case Status.FULFILLED: fulfulled(this.value) break; // 进入then方法失败，执行onRejected函数 case Status.REJECTED: rejected(this.reason) break; default: break; &#125; &#125;&#125;","categories":[],"tags":[]},{"title":"webpack学习笔记","slug":"webpack学习笔记","date":"2021-06-26T09:39:36.000Z","updated":"2021-06-26T13:50:02.940Z","comments":true,"path":"2021/06/26/webpack学习笔记/","link":"","permalink":"https://github.com/fengyk1/2021/06/26/webpack%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"webpack构建流程webpack的运行流程是一个串行的过程，从启动到结束会依次执行以下流程：首先会从配置文件和Shell渔具中读取与合并参数，并初始化需要使用的插件和配置插件等执行环境所需要的参数；初始化完成后悔调用Compiler的run来真正启动webpack编译构建过程，webpack的构建流程包括compile、make、build、seal、emit阶段，执行完这些阶段就完成了构建过程。 初始化entry-options启动从配置文件和Shell渔具中读取与合并参数，得出最终的参数。 run实例化Compiler:用上一步得到的参数初始化Compiler对象，加载所有配置的插件，执行对象的run方法开始执行编译 编译构建entry 确定入口根据配置中的entry找出所有的入口文件 make 编译模块从入口文件触发，调用所有配置的Loader对模块进行翻译，再找出该模块依赖的模块，再地柜本步骤直到所有入口依赖的文件都经过了本步骤处理 seal 输出资源根据入口和模块之前的依赖关系，组装一个个包含多个模块的Chunk，再把每个Chunk转换成一个单独的文件加入到输出列表，这步是可以修改输出的内容的最后机会 输出完成在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://github.com/fengyk1/tags/javascript/"}]},{"title":"React Fiber学习笔记","slug":"React-Fiber学习笔记","date":"2021-06-26T09:35:47.000Z","updated":"2021-06-26T09:36:03.219Z","comments":true,"path":"2021/06/26/React-Fiber学习笔记/","link":"","permalink":"https://github.com/fengyk1/2021/06/26/React-Fiber%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"Fiber笔记 fiber是一个调度，在浏览器处理完js，媒体查询，事件等操作后如果有空闲时间会把时间让出来让react去使用，执行自己的任务 fiber也是一种数据结构，子元素有一个指针指向父元素，兄弟元素之前也有相互的指针 fiber是通过requestAnimationFrame和MessageChannel进行模拟实现的requestIdleCallback Fiber架构有两个主要阶段： Reconciliation/render阶段和commit阶段。在源码中，大部分地方都会把”reconciliation阶段”成为”render阶段”。就是在render阶段里面，react遍历了组件树，并且做了以下这些事情 更新state和props 调用生命周期函数 通过调用render方法，从组件中获取children 把获取到的children跟之前的children相比 最后计算出需要执行的DOM操作是什么 在fiber架构中，所有的这些activity都成为”work”。一个fiber node需要做什么样的work取决于其对应的react element是什么类型。比如，对于一个class component而言，React需要做的work就是实例化这个组件。而对于functional component来说，他没有这样的work需要去完成。 ​ requestAnimationFrame 每一帧执行前会执行这个方法 requestAnimationFrame属于高优先级任务 requestIdleCallback 每一帧执行完成后有空余时间才会执行，不一定每一帧都会执行，属于低优先级任务 浏览器很长时间没有执行其他任务，那么idlecallback时间会延长，最长是50ms MessageChannel requestIdleCallback目前只有chrome支持 所以目前React利用MessageChannel模拟了requestIdleCallback，将回调延迟到绘制之后执行 MessageChannel API运行我们创建一个新的消息通道，并通过它的两个MessagePort属性发送数据 MessageChannel创建了一个通信的管道，这个管道有两个端口，每个端口都可以通过postMessage发送数据，而一个端口只要绑定了onmessage回调方法，就可以接收到信息 MessageChannel是一个宏任务 例如: 12345678910111213let channel = new MessageChannel()let port1 = channel.port1let port2 = channel.port2port1.onmessage = function(event)&#123; console.log(&#x27;port1收到来自port2的数据&#x27;,event.data)&#125;port2.onmessage = function(event)&#123; console.log(&#x27;port2收到来自port1的数据&#x27;,event.data)&#125;// postMessage是一个宏任务，在渲染之后执行的port1.postMessage(&#x27;发送给port2&#x27;)port1.postMessage(&#x27;发送给port1&#x27;)","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://github.com/fengyk1/tags/javascript/"}]},{"title":"js模块化笔记","slug":"js模块化笔记","date":"2021-06-23T02:34:04.000Z","updated":"2021-06-23T02:34:38.657Z","comments":true,"path":"2021/06/23/js模块化笔记/","link":"","permalink":"https://github.com/fengyk1/2021/06/23/js%E6%A8%A1%E5%9D%97%E5%8C%96%E7%AC%94%E8%AE%B0/","excerpt":"","text":"Commonjscommonjs模块的加载几十是，输入的是被输出的值的拷贝。也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。 1234567// main.jsvar counter = require(&#x27;./lib&#x27;).counter;var incCounter = require(&#x27;./lib&#x27;).incCounter;console.log(counter); // 3incCounter();console.log(counter); // 3 上面代码说明，counter输出以后，lib.js模块内部的变化就影响不到counter了。这是因为counter是一个原始类型的值，会被缓存。 common.js规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。 AMDAMD模块定义非常清晰，不会污染全局环境，能够清楚的显示依赖关系。AMD模式可以用于浏览器环境，并且允许非同步加载模块，也可以根据需要动态加载模块。 CMDCMD规范专门用于浏览器端，模块的加载是异步的，模块使用时才会加载执行。CMD规范整合了CommonJS和AMD规范的特点。在Sea.js中，所有JavaScript模块都遵循CMD模块定义规范。 12345678910//定义有依赖的模块define(function(require, exports, module)&#123; //引入依赖模块(同步) var module2 = require(&#x27;./module2&#x27;) //引入依赖模块(异步) require.async(&#x27;./module3&#x27;, function (m3) &#123; &#125;) //暴露模块 exports.xxx = value&#125;) ES6模块化ES6模块的设计思想是尽量的静态化，是的编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS和AMD模块，都只能在运行时确定这些东西。比如，CommonJS模块就是对象，输入时必须查找对象属性。 ES6模块与CommonJS模块的差异他们又两个重大差异: CommonJS模块输出的是一个值的拷贝，ES6模块输出的是值的引用。 CommonJS模块是运行时加载，ES6模块是编译时输出接口 因为Commonjs加载的是一个对象(即module.exports属性)，该对象只有在脚本运行完才会生成。而ES6模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。 总结 CommonJS规范主要用于服务端编程，加载模块是同步的，这并不适合在浏览器环境，因为同步意味着阻塞加载，浏览器资源是异步加载的，因此有了AMD CMD解决方案 AMD规范在浏览器环境中异步加载模块，而且可以并行加载多个模块。不过，AMD规范开发成本高，代码的阅读和书写比较困难，模块定义方式的语义不顺畅。 CMD规范和AMD规范很相似，都用于浏览器变成，依赖就近，延迟执行，可以很容易在Node.js中运行。不过，依赖SPM打包，模块的加载逻辑偏重 ES6在语言标准的层面上，实现了模块功能，而且变得相当简单，完全可以取代CommonJS和AMD规范，成为浏览器和服务器通用的模块解决方案","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://github.com/fengyk1/tags/javascript/"}]},{"title":"react高阶组件","slug":"react高阶组件","date":"2021-06-07T14:40:46.000Z","updated":"2021-06-08T02:48:40.174Z","comments":true,"path":"2021/06/07/react高阶组件/","link":"","permalink":"https://github.com/fengyk1/2021/06/07/react%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6/","excerpt":"","text":"什么是高阶组件(HOC)？ 高阶组件就是一个组件包裹着另外一个组件 1234567891011function WithComponent(Wrapper)&#123; return class WrapComponent extends React.Component&#123; render()&#123; return ( &lt;div&gt; &lt;Wrapper /&gt; &lt;/div&gt; ) &#125; &#125;&#125;","categories":[],"tags":[{"name":"react","slug":"react","permalink":"https://github.com/fengyk1/tags/react/"}]},{"title":"call,apply,bind的模拟实现","slug":"call-apply-bind的模拟实现","date":"2021-06-03T07:40:34.000Z","updated":"2021-06-07T10:25:59.706Z","comments":true,"path":"2021/06/03/call-apply-bind的模拟实现/","link":"","permalink":"https://github.com/fengyk1/2021/06/03/call-apply-bind%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0/","excerpt":"","text":"以前面试经常被问到call,apply,bind的区别是什么，一直也没有深入研究，趁着这这两比较空闲，打算研究一下这个问题 三者的区别 首页call和apply的区别在于call后面的参数是每一个进行传递。例如: 123456789101112131415161718var obj = &#123; name: 1&#125;function addAgeProp(age)&#123; this.age = age&#125;function addHighProp(high)&#123; this.high = high&#125;addAgeProp.call(obj,18) // 使用call进行传参console.log(obj)addHighProp.apply(obj,[1.80])console.log(obj) 而bind则是延迟调用，使用bind函数不会立即生效，需要把函数再次进行执行后才会生效 12345678910var obj = &#123; name: 1&#125;function addAgeProp(age)&#123; this.age = age&#125;var exec = addAgeProp.bind(obj,18)console.log(exec()) // 只有当执行后面的函数后obj的身上才会多一个age属性 接下来我们来分别来模拟实现一下这三个函数 1234567891011121314151617181920Function.prototype.call2 = function()&#123; var args = [...arguments] // 处理参数 var ctx = args.shift() || window; // 如果参数为null，则对象指向window ctx.fn = this // 把函数挂在传入的对象下面执行 ctx.fn(...args) delete ctx.fn // 最后删除函数、返回当前对象 return ctx&#125;var obj = &#123; name: 1&#125;function addAgeProp(age)&#123; this.age = age&#125;addAgeProp.call2(obj,18)console.log(obj)addAgeProp.call2(null,18) apply的实现跟call一致，只需要在传递参数的时候把rest参数改为数组即可 bind的延迟执行采用了函数柯里化，在内部返回了一个函数，所以需要再执行一次才会执行 12345678Function.prototype.bind2 = function()&#123; var fn = this; var args = [].slice.apply(arguments) var ctx = args.shift() || window; return function()&#123; fn.apply(ctx,args.concat(...arguments)) &#125;&#125;","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://github.com/fengyk1/tags/javascript/"}]},{"title":"防抖和节流的作用及实现","slug":"防抖和节流的作用及实现","date":"2021-06-03T06:16:50.000Z","updated":"2021-06-07T09:43:15.913Z","comments":true,"path":"2021/06/03/防抖和节流的作用及实现/","link":"","permalink":"https://github.com/fengyk1/2021/06/03/%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81%E7%9A%84%E4%BD%9C%E7%94%A8%E5%8F%8A%E5%AE%9E%E7%8E%B0/","excerpt":"","text":"函数防抖和函数节流是一种高频率执行js的优化手段，比如浏览器中的resize,scroll,鼠标mouseover,mouseover等事件触发会一直不断的调用绑定在事件上的回调函数，极大的浪费资源，降低性能。为了优化体验，需要对这类事件进行调用次数限制 函数防抖 事件被触发n秒后执行回调，如果执行期间触发，将重新计时 根据以上规则我们来编写一个防抖函数 123456789101112131415161718function debounce(fn,delay)&#123; var timer = null; var _this = this; return function()&#123; var args = [].slice.apply(arguments) if (timer)&#123; clearTimeout(timer) &#125; timer = setTimeout(()=&gt;&#123; fn.apply(_this, args) &#125;,delay) &#125;&#125;var test = debounce(()=&gt;&#123; console.log(1111)&#125;,1000)test() 函数节流 节流是在执行函数的时候每隔一定的事件，只执行一次 1234567891011121314151617181920function throttle(fn,delay)&#123; var timer = null; return function()&#123; var _this = this var args = arguments if (!timer)&#123; timer = setTimeout(()=&gt;&#123; fn.apply(_this,args); timer = null; &#125;,delay) &#125; &#125;&#125;const test = throttle(()=&gt;&#123; console.log(&#x27;5秒只执行一次&#x27;)&#125;,5000)test()","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://github.com/fengyk1/tags/javascript/"}]}],"categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://github.com/fengyk1/tags/javascript/"},{"name":"react","slug":"react","permalink":"https://github.com/fengyk1/tags/react/"}]}