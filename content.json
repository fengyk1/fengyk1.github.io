{"meta":{"title":"封阳葵的博客","subtitle":"","description":"","author":"封阳葵","url":"https://github.com/fengyk1","root":"/"},"pages":[{"title":"about","date":"2021-06-03T04:58:39.000Z","updated":"2021-06-03T04:58:52.451Z","comments":true,"path":"about/index.html","permalink":"https://github.com/fengyk1/about/index.html","excerpt":"","text":""}],"posts":[{"title":"使用ts对fetch进行简单封装","slug":"使用ts对fetch进行简单封装","date":"2021-09-19T05:44:31.000Z","updated":"2021-09-19T06:25:48.860Z","comments":true,"path":"2021/09/19/使用ts对fetch进行简单封装/","link":"","permalink":"https://github.com/fengyk1/2021/09/19/%E4%BD%BF%E7%94%A8ts%E5%AF%B9fetch%E8%BF%9B%E8%A1%8C%E7%AE%80%E5%8D%95%E5%B0%81%E8%A3%85/","excerpt":"","text":"近期打算使用nodejs配合mysql做一个简单的增删改查操作，由于antd没有提供请求相关的api，因此打算对fetch进行一个简单的封装 fetch是XMLHttpRequest的升级版，可以在javascript中发起http请求，浏览器原生支持 fetch和XMLHttpRequest的区别 js fetch使用Promise，因此很大程度上简化了写法 设计更加合理，API分散在(Response、Request、Header)上面 js fetch 通过数据流处理数据，可以对数据进行分块处理，对于请求大文件非常有用，XMLHTTPRequest不支持数据流，不支持分块处理，必须等所有数据请求完成后才能使用 发起get请求12345678// 如果后端返回的内容不是json会报错fetch(url,&#123; // 请求服务器的相关参数 method: &#x27;GET&#x27;, //更多参数可以查询mdn&#125;).then(res=&gt;res.json()).then(res=&gt;&#123; // 从后台拿到的json内容 console.log(res)&#125;) get方式参数需要在地址栏进行传输，如果传递的参数是一个json对象，需要对传入的参数进行处理 发起post请求1234567891011const params = &#123;a:1,b:2&#125;fetch(url,&#123; method: &#x27;POST&#x27;, // POST方式参数需要在body里面进行传递，传递的是一个json字符串 body: JSON.stringify(params), // header上的参数 headers: new Headers(&#123; &#x27;Content-Type&#x27;: &#x27;application/json&#x27; &#125;), // 更多参数可以前往mdn进行查询&#125;) 简单封装fetch1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283// headers信息类型interface HeadersProps&#123; [key:string]:any&#125;// 初始化配置数据类型interface OptionsProps&#123; baseURL:string; // 服务器地址 headers?:HeadersProps; // header信息 timeout?:number; // 超时时长设置&#125;// 请求参数interface FetchParams&#123; url:string; // 请求地址 method:string; // 请求方法，POST、GET params: &#123; // 请求参数 [key:string]:any &#125;&#125;// 请求参数，调用Get或Post时不需要methodinterface FetchOptions&#123; url:string; params:&#123; [key:string]:any &#125;&#125;class Http&#123; baseURL:string = &#x27;&#x27;; headers:HeadersProps = &#123;&#125;; timeout:number = 0; // 保存初始化信息、请求前和请求后的拦截可以在这里保存到实例上，在doGet和doPost分别调用就可以了 constructor(options:OptionsProps)&#123; const &#123;baseURL = &#x27;&#x27;,headers = &#123;&#125;,timeout = 100000&#125; = options this.baseURL = baseURL this.headers = headers || &#123;&#125; this.timeout = timeout &#125; // GET方式处理， private doGet(options:FetchParams)&#123; const &#123;url,method,params&#125; = options // get参数是在地址栏进行传输，需要将参数进行转换 let query = &#x27;&#x27; Object.keys(params).forEach((key,index)=&gt;&#123; query += `$&#123;index === 0 ? &#x27;?&#x27; : &#x27;&amp;&#x27;&#125;$&#123;key&#125;=$&#123;params[key]&#125;` &#125;) // 超时控制，使用Promise.race控制 return this.timeoutFetch(fetch(`$&#123;this.baseURL&#125;$&#123;url&#125;$&#123;query&#125;`, &#123; method &#125;).then((res) =&gt; res.json())) &#125; // post请求处理 private doPost(options:FetchParams)&#123; const &#123;url,method,params&#125; = options return this.timeoutFetch(fetch(`$&#123;this.baseURL&#125;$&#123;url&#125;`, &#123; method, body: JSON.stringify(params), // headers需要在options里面接收，再对初始化参数进行合并，目前没有处理 // TODO headers: new Headers(this.headers) &#125;).then(res=&gt; res.json())) &#125; // 暴露给外层调用的post方法 Post(options:FetchOptions)&#123; return this.doPost(Object.assign(options,&#123;method: &#x27;POST&#x27;&#125;)) &#125; // 暴露给外层调用的get方法 Get(options:FetchOptions)&#123; return this.doGet(Object.assign(options,&#123;method: &#x27;GET&#x27;&#125;)) &#125; // 超时控制 private timeoutFetch(promise:Promise&lt;any&gt;)&#123; const timeoutPromise = (timeout:number)=&gt;&#123; return new Promise((resolve,reject)=&gt;&#123; setTimeout(()=&gt;&#123; reject(new Error(&#x27;超时&#x27;)) &#125;,timeout) &#125;) &#125; // race接收多个Promise，哪个promise先返回结果就返回哪个promise，超时后就不会再等待fetch了 return Promise.race([timeoutPromise(this.timeout),promise]) &#125;&#125;export default Http 使用方式如下 import Http from &#39;./http&#39; const baseURL = &#39;http://xxx&#39; const http = new Http(&#123; baseURL, timeout:1000 &#125;) http.Get(&#123; url: &#39;/login&#39;, params: &#123;username:&#39;admin&#39;, password:&#39;admin&#39;&#125; &#125;).then(res=&gt;&#123; console.log(res) &#125;)``` 注: fetch方法有很多未完善的地方，如需使用请自行完善","categories":[],"tags":[]},{"title":"Promise原理与实现","slug":"Promise原理与实现","date":"2021-09-14T03:20:19.000Z","updated":"2021-09-14T07:18:57.468Z","comments":true,"path":"2021/09/14/Promise原理与实现/","link":"","permalink":"https://github.com/fengyk1/2021/09/14/Promise%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0/","excerpt":"","text":"Promise原理与实现Promise的状态 一个Promise必然处于一下几个状态之一 pendding 初始状态 等待着，既没有成功，也没有失败 fulfilled 成功 rejected 失败 等待状态的Promise会在调用resolve后会变为成功状态，调用reject后变为失败状态，接下来使用es6实现一个最简单的Promise 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859const Status = &#123; PENDDING: &#x27;PENDDING&#x27;, FULFILLED: &#x27;FULFILLED&#x27;, REJECTED: &#x27;REJECTED&#x27;&#125;// Promise类class Promise&#123; // 传入的函数 constructor(exectuer)&#123; // 定义成功函数数组，用来存放成功后的回调函数 this.resolveCallbacks = [] // 定义失败函数数组，用来存放失败后的回调函数 this.rejectCallbacks = [] // 状态 初始状为PENDDING this.status = Status.PENDDING // 调用resolve后传入的值 this.value = undefined; // 调用reject后传入的值 this.reason = undefined; // resolve方法 const resolve = (value)=&gt;&#123; // PENDDING状态下保存相关数据 if (this.status === Status.PENDDING)&#123; this.value = value; this.status = Status.FULFILLED; this.resolveCallbacks.forEach(cb=&gt;cb()) &#125; &#125; // reject方法 const reject = (reason)=&gt;&#123; if (this.status === Status.PENDDING)&#123; this.reason = reason; this.status = Status.REJECTED; this.rejectCallbacks.forEach(cb=&gt;cb()) &#125; &#125; try&#123; exectuer(resolve,reject) &#125;catch(e)&#123; reject(e) &#125; &#125; /** * 注:这里只是把函数保存到数组里面，实际是在resolve方法里面执行 * @onFulfilled 成功执行的函数 * @onRejected 失败执行的函数 */ then(onFulfilled,onRejected)&#123; const fulfulled = onFulfilled || (x=&gt;x) const rejected = onRejected || (x=&gt;x) this.resolveCallbacks.push(()=&gt;&#123; fulfulled(this.value) &#125;) this.rejectCallbacks.push(()=&gt;&#123; rejected(this.reason) &#125;) &#125;&#125;","categories":[],"tags":[]},{"title":"webpack学习笔记","slug":"webpack学习笔记","date":"2021-06-26T09:39:36.000Z","updated":"2021-09-19T06:28:42.972Z","comments":true,"path":"2021/06/26/webpack学习笔记/","link":"","permalink":"https://github.com/fengyk1/2021/06/26/webpack%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"webpack构建流程webpack的运行流程是一个串行的过程，从启动到结束会依次执行以下流程：首先会从配置文件和Shell渔具中读取与合并参数，并初始化需要使用的插件和配置插件等执行环境所需要的参数；初始化完成后悔调用Compiler的run来真正启动webpack编译构建过程，webpack的构建流程包括compile、make、build、seal、emit阶段，执行完这些阶段就完成了构建过程。 初始化entry-options启动从配置文件和Shell语句中读取与合并参数，得出最终的参数。 run实例化Compiler:用上一步得到的参数初始化Compiler对象，加载所有配置的插件，执行对象的run方法开始执行编译 编译构建entry 确定入口根据配置中的entry找出所有的入口文件 make 编译模块从入口文件触发，调用所有配置的Loader对模块进行翻译，再找出该模块依赖的模块，再地柜本步骤直到所有入口依赖的文件都经过了本步骤处理 seal 输出资源根据入口和模块之前的依赖关系，组装一个个包含多个模块的Chunk，再把每个Chunk转换成一个单独的文件加入到输出列表，这步是可以修改输出的内容的最后机会 输出完成在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://github.com/fengyk1/tags/javascript/"}]},{"title":"React Fiber学习笔记","slug":"React-Fiber学习笔记","date":"2021-06-26T09:35:47.000Z","updated":"2021-06-26T09:36:03.219Z","comments":true,"path":"2021/06/26/React-Fiber学习笔记/","link":"","permalink":"https://github.com/fengyk1/2021/06/26/React-Fiber%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"Fiber笔记 fiber是一个调度，在浏览器处理完js，媒体查询，事件等操作后如果有空闲时间会把时间让出来让react去使用，执行自己的任务 fiber也是一种数据结构，子元素有一个指针指向父元素，兄弟元素之前也有相互的指针 fiber是通过requestAnimationFrame和MessageChannel进行模拟实现的requestIdleCallback Fiber架构有两个主要阶段： Reconciliation/render阶段和commit阶段。在源码中，大部分地方都会把”reconciliation阶段”成为”render阶段”。就是在render阶段里面，react遍历了组件树，并且做了以下这些事情 更新state和props 调用生命周期函数 通过调用render方法，从组件中获取children 把获取到的children跟之前的children相比 最后计算出需要执行的DOM操作是什么 在fiber架构中，所有的这些activity都成为”work”。一个fiber node需要做什么样的work取决于其对应的react element是什么类型。比如，对于一个class component而言，React需要做的work就是实例化这个组件。而对于functional component来说，他没有这样的work需要去完成。 ​ requestAnimationFrame 每一帧执行前会执行这个方法 requestAnimationFrame属于高优先级任务 requestIdleCallback 每一帧执行完成后有空余时间才会执行，不一定每一帧都会执行，属于低优先级任务 浏览器很长时间没有执行其他任务，那么idlecallback时间会延长，最长是50ms MessageChannel requestIdleCallback目前只有chrome支持 所以目前React利用MessageChannel模拟了requestIdleCallback，将回调延迟到绘制之后执行 MessageChannel API运行我们创建一个新的消息通道，并通过它的两个MessagePort属性发送数据 MessageChannel创建了一个通信的管道，这个管道有两个端口，每个端口都可以通过postMessage发送数据，而一个端口只要绑定了onmessage回调方法，就可以接收到信息 MessageChannel是一个宏任务 例如: 12345678910111213let channel = new MessageChannel()let port1 = channel.port1let port2 = channel.port2port1.onmessage = function(event)&#123; console.log(&#x27;port1收到来自port2的数据&#x27;,event.data)&#125;port2.onmessage = function(event)&#123; console.log(&#x27;port2收到来自port1的数据&#x27;,event.data)&#125;// postMessage是一个宏任务，在渲染之后执行的port1.postMessage(&#x27;发送给port2&#x27;)port1.postMessage(&#x27;发送给port1&#x27;)","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://github.com/fengyk1/tags/javascript/"}]},{"title":"js模块化笔记","slug":"js模块化笔记","date":"2021-06-23T02:34:04.000Z","updated":"2021-09-19T06:28:02.183Z","comments":true,"path":"2021/06/23/js模块化笔记/","link":"","permalink":"https://github.com/fengyk1/2021/06/23/js%E6%A8%A1%E5%9D%97%E5%8C%96%E7%AC%94%E8%AE%B0/","excerpt":"","text":"Commonjscommonjs模块的加载时机是，输入的是被输出的值的拷贝。也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。 1234567// main.jsvar counter = require(&#x27;./lib&#x27;).counter;var incCounter = require(&#x27;./lib&#x27;).incCounter;console.log(counter); // 3incCounter();console.log(counter); // 3 上面代码说明，counter输出以后，lib.js模块内部的变化就影响不到counter了。这是因为counter是一个原始类型的值，会被缓存。 common.js规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。 AMDAMD模块定义非常清晰，不会污染全局环境，能够清楚的显示依赖关系。AMD模式可以用于浏览器环境，并且允许非同步加载模块，也可以根据需要动态加载模块。 CMDCMD规范专门用于浏览器端，模块的加载是异步的，模块使用时才会加载执行。CMD规范整合了CommonJS和AMD规范的特点。在Sea.js中，所有JavaScript模块都遵循CMD模块定义规范。 12345678910//定义有依赖的模块define(function(require, exports, module)&#123; //引入依赖模块(同步) var module2 = require(&#x27;./module2&#x27;) //引入依赖模块(异步) require.async(&#x27;./module3&#x27;, function (m3) &#123; &#125;) //暴露模块 exports.xxx = value&#125;) ES6模块化ES6模块的设计思想是尽量的静态化，是的编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS和AMD模块，都只能在运行时确定这些东西。比如，CommonJS模块就是对象，输入时必须查找对象属性。 ES6模块与CommonJS模块的差异他们又两个重大差异: CommonJS模块输出的是一个值的拷贝，ES6模块输出的是值的引用。 CommonJS模块是运行时加载，ES6模块是编译时输出接口 因为Commonjs加载的是一个对象(即module.exports属性)，该对象只有在脚本运行完才会生成。而ES6模块不是对象，它的对外接口只是一种静态定义，在代码静态解析阶段就会生成。 总结 CommonJS规范主要用于服务端编程，加载模块是同步的，这并不适合在浏览器环境，因为同步意味着阻塞加载，浏览器资源是异步加载的，因此有了AMD CMD解决方案 AMD规范在浏览器环境中异步加载模块，而且可以并行加载多个模块。不过，AMD规范开发成本高，代码的阅读和书写比较困难，模块定义方式的语义不顺畅。 CMD规范和AMD规范很相似，都用于浏览器变成，依赖就近，延迟执行，可以很容易在Node.js中运行。不过，依赖SPM打包，模块的加载逻辑偏重 ES6在语言标准的层面上，实现了模块功能，而且变得相当简单，完全可以取代CommonJS和AMD规范，成为浏览器和服务器通用的模块解决方案","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://github.com/fengyk1/tags/javascript/"}]},{"title":"react高阶组件","slug":"react高阶组件","date":"2021-06-07T14:40:46.000Z","updated":"2021-06-08T02:48:40.174Z","comments":true,"path":"2021/06/07/react高阶组件/","link":"","permalink":"https://github.com/fengyk1/2021/06/07/react%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6/","excerpt":"","text":"什么是高阶组件(HOC)？ 高阶组件就是一个组件包裹着另外一个组件 1234567891011function WithComponent(Wrapper)&#123; return class WrapComponent extends React.Component&#123; render()&#123; return ( &lt;div&gt; &lt;Wrapper /&gt; &lt;/div&gt; ) &#125; &#125;&#125;","categories":[],"tags":[{"name":"react","slug":"react","permalink":"https://github.com/fengyk1/tags/react/"}]},{"title":"call,apply,bind的模拟实现","slug":"call-apply-bind的模拟实现","date":"2021-06-03T07:40:34.000Z","updated":"2021-09-19T06:28:21.694Z","comments":true,"path":"2021/06/03/call-apply-bind的模拟实现/","link":"","permalink":"https://github.com/fengyk1/2021/06/03/call-apply-bind%E7%9A%84%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0/","excerpt":"","text":"以前面试经常被问到call,apply,bind的区别是什么，一直也没有深入研究，趁着这两天比较空闲，打算研究一下这个问题 三者的区别 首页call和apply的区别在于call后面的参数是每一个进行传递。例如: 123456789101112131415161718var obj = &#123; name: 1&#125;function addAgeProp(age)&#123; this.age = age&#125;function addHighProp(high)&#123; this.high = high&#125;addAgeProp.call(obj,18) // 使用call进行传参console.log(obj)addHighProp.apply(obj,[1.80])console.log(obj) 而bind则是延迟调用，使用bind函数不会立即生效，需要把函数再次进行执行后才会生效 12345678910var obj = &#123; name: 1&#125;function addAgeProp(age)&#123; this.age = age&#125;var exec = addAgeProp.bind(obj,18)console.log(exec()) // 只有当执行后面的函数后obj的身上才会多一个age属性 接下来我们来分别来模拟实现一下这三个函数 1234567891011121314151617181920Function.prototype.call2 = function()&#123; var args = [...arguments] // 处理参数 var ctx = args.shift() || window; // 如果参数为null，则对象指向window ctx.fn = this // 把函数挂在传入的对象下面执行 ctx.fn(...args) delete ctx.fn // 最后删除函数、返回当前对象 return ctx&#125;var obj = &#123; name: 1&#125;function addAgeProp(age)&#123; this.age = age&#125;addAgeProp.call2(obj,18)console.log(obj)addAgeProp.call2(null,18) apply的实现跟call一致，只需要在传递参数的时候把rest参数改为数组即可 bind的延迟执行采用了函数柯里化，在内部返回了一个函数，所以需要再执行一次才会执行 12345678Function.prototype.bind2 = function()&#123; var fn = this; var args = [].slice.apply(arguments) var ctx = args.shift() || window; return function()&#123; fn.apply(ctx,args.concat(...arguments)) &#125;&#125;","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://github.com/fengyk1/tags/javascript/"}]},{"title":"防抖和节流的作用及实现","slug":"防抖和节流的作用及实现","date":"2021-06-03T06:16:50.000Z","updated":"2021-06-07T09:43:15.913Z","comments":true,"path":"2021/06/03/防抖和节流的作用及实现/","link":"","permalink":"https://github.com/fengyk1/2021/06/03/%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81%E7%9A%84%E4%BD%9C%E7%94%A8%E5%8F%8A%E5%AE%9E%E7%8E%B0/","excerpt":"","text":"函数防抖和函数节流是一种高频率执行js的优化手段，比如浏览器中的resize,scroll,鼠标mouseover,mouseover等事件触发会一直不断的调用绑定在事件上的回调函数，极大的浪费资源，降低性能。为了优化体验，需要对这类事件进行调用次数限制 函数防抖 事件被触发n秒后执行回调，如果执行期间触发，将重新计时 根据以上规则我们来编写一个防抖函数 123456789101112131415161718function debounce(fn,delay)&#123; var timer = null; var _this = this; return function()&#123; var args = [].slice.apply(arguments) if (timer)&#123; clearTimeout(timer) &#125; timer = setTimeout(()=&gt;&#123; fn.apply(_this, args) &#125;,delay) &#125;&#125;var test = debounce(()=&gt;&#123; console.log(1111)&#125;,1000)test() 函数节流 节流是在执行函数的时候每隔一定的事件，只执行一次 1234567891011121314151617181920function throttle(fn,delay)&#123; var timer = null; return function()&#123; var _this = this var args = arguments if (!timer)&#123; timer = setTimeout(()=&gt;&#123; fn.apply(_this,args); timer = null; &#125;,delay) &#125; &#125;&#125;const test = throttle(()=&gt;&#123; console.log(&#x27;5秒只执行一次&#x27;)&#125;,5000)test()","categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://github.com/fengyk1/tags/javascript/"}]}],"categories":[],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://github.com/fengyk1/tags/javascript/"},{"name":"react","slug":"react","permalink":"https://github.com/fengyk1/tags/react/"}]}